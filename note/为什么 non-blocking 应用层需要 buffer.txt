1. 
IO 线程只能阻塞在 select/poll/epoll_wait 上。

2.
针对用户，发送数据仅使用 send() 接口，不管数据如何发送。
    2.1
    发送 100k 数据，可能分 N 种情况发送。
        (1）调用 write( ), 系统只接受了 80k，剩余的 20k 怎么办
        (2）调用 wtire( ), 系统只接收了 50k，剩余的 50k 怎么办
        (3）需要调用几次 write(), 不得而知
    如果 for 循环直接 write()，则会阻塞，阻塞多久未知。
对应用程序而言，它只管生产数据，不关心如何发送，分几次发送，这些
由网络库来负责。

如 2.1 的 (1), 剩余的 20k 应该保存在 buffer 里面，然后注册 POLLOUT 事件，
一旦 socket 可写，立刻发送，以此类推。

    2.2 
    如果 buffer 現有 20k 数据没发送，应用程序又发送 50k，显然，50k 数据应该
    append 在 20k 数据后面，等 socket 可写再一并发送。

综上，要让程序在 write 上不阻塞，网络库必须要给每个 TcpConnection 分配 output buffer.

3.
TCP 是一个无边界的字节流协议，接收方需要处理 “收到的消息不构成一条完整的消息”的情况。
   3.1
   比如，发送方要发送 2k 的数据，接收方可能的情况是
       (1) 一次性接收 2k 数据
       (2) 分两次收到，一次 1k
       (3) 分两次收到，一次 1.5k, 一次 0.5k
       (4) 分 N 次收到.....
网络库应对收到的数据还不完整的情况，通常是 codec 的职责，收到的数据先放在 input buffer,
等到构成一条完整的数据再通知给上层应用。

4.
编解码器 codec 负责确认接收的数据是一条完整的消息

综上，就是需要 buffer 的原因了 

 